---
interface Props {
  animation?: 'fade-up' | 'fade-left' | 'fade-right' | 'scale' | 'fade';
  delay?: number;
  duration?: number;
  threshold?: number;
  class?: string;
  once?: boolean;
}

const { 
  animation = 'fade-up', 
  delay = 0, 
  duration = 600,
  threshold = 0.1,
  class: className = '',
  once = true
} = Astro.props;

const animationClass = {
  'fade-up': 'reveal',
  'fade-left': 'reveal-left',
  'fade-right': 'reveal-right',
  'scale': 'reveal-scale',
  'fade': 'reveal'
}[animation];
---

<div 
  class={`scroll-reveal ${animationClass} ${className}`}
  data-threshold={threshold}
  data-once={once}
  style={`transition-delay: ${delay}ms; transition-duration: ${duration}ms;`}
>
  <slot />
</div>

<script>
  // Intersection Observer for scroll reveal
  const observerOptions = {
    root: null,
    rootMargin: '0px 0px -50px 0px',
    threshold: 0.1
  };

  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add('revealed');
        
        // If once is true, unobserve after revealing
        const once = entry.target.getAttribute('data-once') !== 'false';
        if (once) {
          observer.unobserve(entry.target);
        }
      } else {
        // If not once, remove revealed class when scrolling out
        const once = entry.target.getAttribute('data-once') !== 'false';
        if (!once) {
          entry.target.classList.remove('revealed');
        }
      }
    });
  }, observerOptions);

  // Observe all scroll-reveal elements
  document.querySelectorAll('.scroll-reveal').forEach(el => {
    observer.observe(el);
  });

  // Re-observe after view transitions
  document.addEventListener('astro:page-load', () => {
    document.querySelectorAll('.scroll-reveal').forEach(el => {
      observer.observe(el);
    });
  });
</script>
